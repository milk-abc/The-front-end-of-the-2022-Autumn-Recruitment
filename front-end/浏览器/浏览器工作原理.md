浏览器是多进程的

```
- 进程是一个工厂，工厂有它的独立资源

- 工厂之间相互独立

- 线程是工厂中的工人，多个工人协作完成任务

- 工厂内有一个或多个工人

- 工人之间共享空间
-----------------------------------
- 工厂的资源 -> 系统分配的内存（独立的一块内存）

- 工厂之间的相互独立 -> 进程之间相互独立

- 多个工人协作完成任务 -> 多个线程在进程中协作完成任务

- 工厂内有一个或多个工人 -> 一个进程由一个或多个线程组成

- 工人之间共享空间 -> 同一进程下的各个线程之间共享程序的内存空间（包括代码段、数据集、堆等）
```

可以打开任务管理器查看cpu是否给浏览器每个页面分配了内存来判断其是否为多进程。

包含以下进程：

```
1.Browser进程：浏览器的主进程（负责协调、主控），只有一个。作用有

负责浏览器界面显示，与用户交互。如前进，后退等

负责各个页面的管理，创建和销毁其他进程

将Renderer进程得到的内存中的Bitmap，绘制到用户界面上

网络资源的管理，下载等

2.第三方插件进程：每种类型的插件对应一个进程，仅当使用该插件时才创建

GPU进程：最多一个，用于3D绘制等

3.浏览器渲染进程（浏览器内核）（Renderer进程，内部是多线程的）：默认每个Tab页面一个进程，互不影响。
主要作用为页面渲染，脚本执行，事件处理等
```

![img](https://pica.zhimg.com/80/v2-93d0c17b38b6ffa2acf78fe1d608fef4_720w.png?source=d16d100b)





添加图片注释，不超过 140 字（可选）

1.GUI线程：渲染页面

- 处理HTML标记并构建DOM树，包含了页面的所有内容
- 处理CSS标记并构建CSSDOM树，包含了页面的所有样式
- 将DOM与CSSOM合并成一个渲染树，对于每个可见节点，为其找到适配的 CSSOM 规则并应用它们
- 根据渲染树来布局，以计算每个节点的几何信息
- 绘制渲染树的各个节点，绘制页面像素信息
- 浏览器会将各层的信息发送给GPU，GPU会将各层合成，显示在屏幕上
- 重绘和回流
- GUI渲染线程与JS引擎线程互斥

2.JS引擎线程

JSV8引擎，负责解析Javascript脚本，运行代码。是单线程，JS如果执行时间过长就会阻塞页面。

WebWorker-----JS的多线程

- 创建Worker时，JS引擎向浏览器申请开一个子线程（子线程是浏览器开的，完全受主线程控制，而且不能操作DOM）
- JS引擎线程与worker线程间通过特定的方式通信（postMessage API，需要通过序列化对象来与线程交互特定的数据）

3.定时触发器线程

- 浏览器定时计数器并不是由JavaScript引擎计数的,（因为JavaScript引擎是单线程的, 如果处于阻塞线程状态就会影响记计时的准确）
- 因此通过单独线程来计时并触发定时（计时完毕后，添加到任务队列中，等待JS引擎空闲后执行)

4.事件触发线程

定时器线程其实只是一个计时的作用，他并不会真正执行时间到了的回调，真正执行这个回调的还是JS主线程。所以当时间到了定时器线程会将这个回调事件给到事件触发线程，然后事件触发线程将它加到事件队列里面去。最终JS主线程从事件队列取出这个回调执行。事件触发线程不仅会将定时器事件放入任务队列，其他满足条件的事件也是他负责放进任务队列。

5.异步http请求线程

- XMLHttpRequest连接后是通过浏览器新开一个线程请求
- 检测到状态变更时，如果设置有回调函数，异步线程就**产生状态变更事件**，将这个回调再放入事件队列中。再由JavaScript引擎执行

JS引擎的事件循环：

**宏任务有主程序代码，setTimeout, setInterval, setImmediate，I/O, UI rendering**

**微任务有process.nextTick,Promises,async,MutationObserver**

**process.nextTick会在此次宏任务同步代码执行完后立即执行，位于promise执行前**

- **整个脚本作为一个宏任务执行，宏任务出队**
- **每次执行时，先看看要执行的是同步任务还是异步的API**
- **同步代码直接执行，遇到异步API将其交给对应的异步线程，自己继续执行同步任务**
- **异步线程执行异步API，执行完后，将异步回调事件放入对应的事件队列上，宏任务放入宏任务队列，微任务放入微任务队列**
- **主线程上的同步任务执行完后检查微任务列表，有则依次执行，直到执行完**
- **下一个宏任务出队，回到2，依此循环，直到宏任务和微任务队列都为空**

![img](https://picx.zhimg.com/80/v2-1a7231657ba6c5cda29e175e59c73b0e_720w.png?source=d16d100b)

从浏览器多进程到JS单线程，JS运行机制最全面的一次梳理 | Dailc的个人主页www.dailichun.com/2018/01/21/js_singlethread_eventloop.html

浏览器进程线程、Web Workers、Event Loop 图解segmentfault.com/a/1190000017204460

![js核心系列流程图.png](https://p1-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/73095811d8d241e8abe4f004e0e09eef~tplv-k3u1fbpfcp-zoom-in-crop-mark:1512:0:0:0.awebp?)

##### 1.js为什么是单线程

作为浏览器脚本语言，js的主要用途是与用户互动，以及操作DOM，这决定了它只能是单线程，否则会带来很复杂的同步问题。比如JS同时有两个线程，一个线程在DOM节点上新增内容，另一个线程删除了这个节点，这时浏览器应该以哪个线程为准？

为了利用多核CPU的计算能力，HTML5提出Web Worker标准，允许js脚本创建多个线程，但子线程完全受主线程控制，且不得操作DOM。所以这个新标准并没有改变js单线程的本质。

##### 2.nodejs的event loop

![Node.js](https://www.ruanyifeng.com/blogimg/asset/2014/bg2014100803.png)

 (1)v8引擎解析js脚本

(2)解析后的代码，调用node api

(3)libuv库负责node api的执行。它将不同的任务分配给不同的线程，形成一个EventLoop，以异步的方式将任务的执行结果返回给v8引擎。

(4)v8引擎再将结果返回给用户。

##### 3.浏览器环境下的event loop

(1)所有同步任务都在主线程上执行，形成一个执行栈

(2)主线程之外，还存在一个“任务队列”。只要异步任务有了运行结果，就在任务队列中放置一个事件。

(3)一旦执行栈中的所有同步任务执行完毕，系统就会读取“任务队列”，看看里面有哪些事件。那些对应的异步任务，于是结束等待状态，进入执行栈，开始执行。

##### 4.什么是v8引擎

是一种js引擎，一个执行js代码的程序或解释器，是以某种形式将js编译为字节码的编译器。

用户通过在地址栏输入一个URL、点击一个链接、提交表单或者其他的行为。

DNS查询

![image-20240318135441117](C:\Users\liqian\AppData\Roaming\Typora\typora-user-images\image-20240318135441117.png)

![image-20240318135502819](C:\Users\liqian\AppData\Roaming\Typora\typora-user-images\image-20240318135502819.png)

https://juejin.cn/post/6871947938701475847

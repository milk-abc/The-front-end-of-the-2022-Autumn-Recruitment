![img](https://pica.zhimg.com/80/v2-a12089d5fea727332a8aba4ce009891a_720w.webp?source=d16d100b)

1.缓存的作用：可以降低资源的重复加载提高网页的整体加载速度

2.浏览器缓存策略：强缓存和协商缓存

基本原理：

1）浏览器在加载资源时，根据请求头的expires和cache-control判断是否命中强缓存，是则直接从缓存读取资源，不会发请求到服务器，返回状态码为200(from cache)。

2）如果没有命中强缓存，浏览器一定会发送一个请求到服务器，通过last-modified和etag验证资源是否命中协商缓存，如果命中，服务器会将这个请求返回，但是不会返回这个资源的数据，依然是从缓存中读取资源，返回状态码为304。

3）如果前面两者都没有命中，直接从服务器加载资源

强调一点：所有的缓存标识都是服务器生成的，expires,cache-control,last-modified,etag，想想token是怎么实现的，缓存标识是一样的，都是第一次请求发送到服务器，服务器生成缓存标识发给客户端，客户端下次请求带上标识和服务器进行对比，再执行以下操作。

强缓存

1)expires

当我们请求一个资源，服务器返回时，可以在Response Header中添加expires字段表示资源的过期时间。

![img](https://picx.zhimg.com/80/v2-7d73c719873a6d254b113cdaee9a2378_720w.webp?source=d16d100b)

当客户端再次请求该资源的时候，会把客户端时间与expire时间(绝对时间)进行对比，如果小于该时间直接使用该缓存资源。但客户端和服务端时间可能快慢不一致，另一方面，客户端的时间可以自行修改，可能会出现缓存混乱。

2)cache-control

cache-control是http1.1引入来解决此问题的，因此当cache-control和expires都存在时，cache-control优先级更高。一般常用该字段的`max-age`值来进行判断，它是一个相对时间，比如 .`Cache-Control:max-age=3600`代表资源的有效期是 3600 秒。并且返回头中的`Date`表示消息发送的时间，表示当前资源在`Date ~ Date +3600s`这段时间里都是有效的。

- `no-cache` 可以存储到本地，但是在与服务器进行新鲜度再验证前，缓存不能将其提供给客户端使用。
- `no-store`直接禁止浏览器缓存数据，每次请求资源都会向服务器要完整的资源， 类似于 `network` 中的 `disabled cache`。
- `public` 可以被所有用户缓存，包括终端用户和 cdn 等中间件代理服务器。
- `private` 只能被终端用户的浏览器缓存。

协商缓存

1)last-modified

last-modified记录资源最后修改的时间。启用后，请求资源之后的响应头会增加一个last-modified字段，如上。

当再次请求该资源时，请求头中会带有if-modified-since字段，值是之前返回的last-modified的值。服务端会对比该字段和last-modified，若一致则证明没有被修改，告知浏览器可直接使用客户端的缓存并返回304；若不一致则直接返回服务器的修改后的资源，返回200 ，客户端如第一次接受该资源一样，记下它的cache-control中的max-age、etag、last-modified等。

但是last-modified有以下两个缺点：

1、只要编辑了，不管内容是否真的有改变，都会以这最后修改的时间作为判断依据，当成新资源返回，从而导致了没必要的请求响应

2、时间的精确度只能到秒，如果在一秒内的修改是检测不到更新的，依然会告知浏览器使用旧的缓存。

3、某些服务器不能精确的得到文件的最后修改时间。

2)etag

为了解决上述问题，引入了etag，因此etag的优先级高于last-modified，etag就像一个指纹，资源变化都会导致etag变化，跟最后修改时间没有关系，Etag可以保证每一个资源是唯一的。

当再次请求该资源时，请求头中会带有If-None-Match字段，值是之前返回的etag的值，询问服务器该资源的etag是否有更新。



![img](https://pica.zhimg.com/80/v2-e231d2d654aa2b972eee7109539becbc_720w.webp?source=d16d100b)

整体流程

![img](https://picx.zhimg.com/80/v2-06c8da98ecbf4bd352046daafcbd9660_720w.webp?source=d16d100b)

一般部署前端资源文件时，一般会启用服务器的静态资源缓存，对于用户的浏览器而言，就可以缓存住静态资源，后续就不用去请求资源了，提高效率。但使用缓存也有一些问题，如果设置过期时间过短的话就没有很大的作用，过长的话不会更新文件。建议在生产模式下，文件名使用Hash，这样的话一旦资源文件发生改变，文件名称也会一起变化，对于客户端而言，全新的文件名对应全新的请求，这样就可以把缓存时间设置的很长。

##### hash

```js
output:{
    filename:"[name]-[hash].bundle.js"
}
```

项目级别的，一旦项目中有任何地方发生改动，所有文件名称都会发生变化

##### chunkhash

```
output:{
    filename:"[name]-[chunkhash].bundle.js"
}
```

在我们打包中，同一路的打包中有任何地方发生改变，只会影响同一路中的文件名称会发生变化【动态分离】

![image-20240408105731922](C:\Users\liqian\AppData\Roaming\Typora\typora-user-images\image-20240408105731922.png)

当打包到main.js的代码改变后，只会让main-xxx.bundle.js文件修改文件名，其他的不会受到影响。如果是posts.css发生变化了，会把posts.css和posts.js和main.js的文件名都更改，因为是chunk级别的，同一路的

##### contenthash

只要是不同的文件就会有不同的hash值，是文件粒度的hash，如果是posts.css发生变化了，只会更改posts.css和main.js的文件名，因为是文件粒度的，main.js是所有的出口，因此也会一起改变。

---------------------------------------------------------------------------------------------------------------------------------------------------------

Cookie、sessionStorage、localStorage、indexdb 的区别

cookie数据在http请求中携带，4KB

sessionStorage、localStorage仅在本地保存，5M，移动端2.5M，indexdb 50M

cookie一般有服务器生成，可设置失效时间。如果在浏览器端生成的cookie，默认关闭浏览器后失效

##### sessionStorage仅在当前浏览器窗口关闭前有效

localStorage始终有效，窗口或浏览器关闭也一直保存，因此用作持久数据

indexDB持久数据

------------------------------------------------------------------------------------------------------

sessionStorage不在不同的浏览器窗口中共享，即使是同一个页面

cookie在所有同源窗口中都是共享的

localStorage 在所有同源窗口中都是共享的

indexDB异步，支持事务，较为复杂

---------------------------------------------------------------------------------------------------------------------------------------------------------

![img](https://pic1.zhimg.com/80/07c2bdef6ccef3ada425d61e3062dd09_720w.webp?source=2c26e567)





让我们返璞归真，从原始的前端开发讲起。上图是一个“可爱”的index.html页面和它的样式文件a.css，用文本编辑器写代码，无需编译，本地预览，确认OK，丢到服务器，等待用户访问。前端就是这么简单，好好玩啊，门槛好低啊，分分钟学会有木有！

![img](https://picx.zhimg.com/80/d53b504bbc9f1887eddf06d90545b870_720w.webp?source=2c26e567)





然后我们访问页面，看到效果，再查看一下网络请求，200！不错，太™完美了！那么，研发完成。。。。了么？

等等，这还没完呢！对于大公司来说，那些变态的访问量和性能指标，将会让前端一点也不“好玩”。

看看那个a.css的请求吧，如果每次用户访问页面都要加载，是不是很影响性能，很浪费带宽啊，我们希望最好这样：

![img](https://pic1.zhimg.com/80/6a611755a5648ca252211cec85a31ac4_720w.webp?source=2c26e567)



利用304，让浏览器使用本地缓存。但，这样也就够了吗？不成！304叫协商缓存，这玩意还是要和服务器通信一次，我们的优化级别是变态级，所以必须彻底灭掉这个请求，变成这样：

![img](https://picx.zhimg.com/80/fd74ab2bf02d79dd7af1336b4c8f180e_720w.webp?source=2c26e567)



强制浏览器使用本地缓存（cache-control/expires），不要和服务器通信。好了，请求方面的优化已经达到变态级别，那问题来了：你都不让浏览器发资源请求了，这缓存咋更新？

很好，相信有人想到了办法：**通过更新页面中引用的资源路径，让浏览器主动放弃缓存，加载新资源**。好像这样：

![img](https://picx.zhimg.com/80/8a8676e933478d1a73777d84a5de55f5_720w.webp?source=2c26e567)



下次上线，把链接地址改成新的版本，就更新资源了不是。OK，问题解决了么？！当然没有！大公司的变态又来了，思考这种情况：

![img](https://picx.zhimg.com/80/4681f7131e777dc885bf66000580ca40_720w.webp?source=2c26e567)



页面引用了3个css，而某次上线只改了其中的a.css，如果所有链接都更新版本，就会导致b.css，c.css的缓存也失效，那岂不是又有浪费了？！

重新开启[变态模式](https://www.zhihu.com/search?q=变态模式&search_source=Entity&hybrid_search_source=Entity&hybrid_search_extra={"sourceType"%3A"answer"%2C"sourceId"%3A32602154})，我们不难发现，要解决这种问题，必须让url的修改与文件内容关联，也就是说，只有文件内容变化，才会导致相应url的变更，从而实现文件级别的精确缓存控制。

什么东西与文件内容相关呢？我们会很自然的联想到利用 [数据摘要要算法](https://link.zhihu.com/?target=http%3A//baike.baidu.com/view/10961371.htm) 对文件求摘要信息，摘要信息与文件内容一一对应，就有了一种可以精确到单个文件粒度的缓存控制依据了。好了，我们把url改成带摘要信息的：

![img](https://pic1.zhimg.com/80/5276595f41d6276e21e5bc1d25741680_720w.webp?source=2c26e567)



这回再有文件修改，就只更新那个文件对应的url了，想到这里貌似很完美了。你觉得这就够了么？大公司告诉你：图样图森破！

唉~~~~，让我喘口气

现代互联网企业，为了进一步提升网站性能，会把静态资源和动态网页分集群部署，静态资源会被部署到[CDN节点](https://www.zhihu.com/search?q=CDN节点&search_source=Entity&hybrid_search_source=Entity&hybrid_search_extra={"sourceType"%3A"answer"%2C"sourceId"%3A32602154})上，网页中引用的资源也会变成对应的部署路径：

![img](https://pica.zhimg.com/80/0866cb58bcf349642d57a06b162e0d91_720w.webp?source=2c26e567)



好了，当我要更新静态资源的时候，同时也会更新html中的引用吧，就好像这样：

![img](https://pic1.zhimg.com/80/16d6d6c32e52ef1d1a835fb2ed15f864_720w.webp?source=2c26e567)



这次发布，同时改了页面结构和样式，也更新了静态资源对应的url地址，现在要发布代码上线，亲爱的前端研发同学，你来告诉我，咱们是先上线页面，还是先上线静态资源？

1. **先部署页面，再部署资源**：在二者部署的时间间隔内，如果有用户访问页面，就会在新的页面结构中加载旧的资源，并且把这个旧版本的资源当做新版本缓存起来，其结果就是：用户访问到了一个样式错乱的页面，除非手动刷新，否则在资源缓存过期之前，页面会一直执行错误。
2. **先部署资源，再部署页面**：在部署时间间隔之内，有旧版本资源本地缓存的用户访问网站，由于请求的页面是旧版本的，资源引用没有改变，浏览器将直接使用本地缓存，这种情况下页面展现正常；但没有本地缓存或者缓存过期的用户访问网站，就会出现旧版本页面加载新版本资源的情况，导致页面执行错误，但当页面完成部署，这部分用户再次访问页面又会恢复正常了。

好的，上面一坨分析想说的就是：先部署谁都不成！都会导致部署过程中发生页面错乱的问题。所以，访问量不大的项目，可以让研发同学苦逼一把，等到半夜偷偷上线，先上静态资源，再部署页面，看起来问题少一些。

但是，大公司超变态，没有这样的“绝对低峰期”，只有“相对低峰期”。So，为了稳定的服务，还得继续追求极致啊！

这个奇葩问题，起源于资源的 **覆盖式发布**，用 待发布资源 覆盖 已发布资源，就有这种问题。解决它也好办，就是实现 **非覆盖式发布**。

![img](https://picx.zhimg.com/80/9b3a9df114d14a14130a70abf5733837_720w.webp?source=2c26e567)



看上图，用文件的摘要信息来对资源文件进行重命名，把摘要信息放到资源文件发布路径中，这样，内容有修改的资源就变成了一个新的文件发布到线上，不会覆盖已有的资源文件。上线过程中，先全量部署静态资源，再灰度部署页面，整个问题就比较完美的解决了。

所以，大公司的静态资源优化方案，基本上要实现这么几个东西：

1. 配置超长时间的本地缓存 —— 节省带宽，提高性能
2. 采用内容摘要作为缓存更新依据 —— 精确的缓存控制
3. 静态资源CDN部署 —— 优化网络请求
4. 更资源发布路径实现非覆盖式发布 —— 平滑升级





全套做下来，就是相对比较完整的静态资源缓存控制方案了，而且，还要注意的是，静态资源的缓存控制要求在**前端所有静态资源加载的位置都要做这样的处理**。是的，所有！什么js、css自不必说，还要包括js、css文件中引用的资源路径，由于涉及到摘要信息，引用资源的摘要信息也会引起引用文件本身的内容改变，从而形成级联的摘要变化，大概示意图就是：

![img](https://pica.zhimg.com/80/edf10bb428d39d721e36760a86d2641e_720w.webp?source=2c26e567)



好了，目前我们快速的学习了一下前端工程中关于静态资源缓存要面临的优化和部署问题，新的问题又来了：这™让工程师怎么写码啊！！！

要解释优化与工程的结合处理思路，又会扯出一堆有关[模块化开发](https://www.zhihu.com/search?q=模块化开发&search_source=Entity&hybrid_search_source=Entity&hybrid_search_extra={"sourceType"%3A"answer"%2C"sourceId"%3A32602154})、资源加载、请求合并、前端框架等等的工程问题，以上只是开了个头，解决方案才是精髓，但要说的太多太多，有空再慢慢展开吧。或者大家可以去我的blog看其中的一些拆解：[fouber/blog · GitHub](https://link.zhihu.com/?target=https%3A//github.com/fouber/blog)

> 总之，前端[性能优化](https://www.zhihu.com/search?q=性能优化&search_source=Entity&hybrid_search_source=Entity&hybrid_search_extra={"sourceType"%3A"answer"%2C"sourceId"%3A32602154})绝逼是一个工程问题！



以上不是我YY的，可以观察 百度 或者 facebook 的页面以及静态资源源代码，查看它们的资源引用路径处理，以及网络请中静态资源的缓存控制部分。再次赞叹facebook的前端工程建设水平，跪舔了。

建议[前端工程师](https://www.zhihu.com/search?q=前端工程师&search_source=Entity&hybrid_search_source=Entity&hybrid_search_extra={"sourceType"%3A"answer"%2C"sourceId"%3A32602154})多多关注前端工程领域，也许有人会觉得自己的产品很小，不用这么变态，但很有可能说不定某天你就需要做出这样的改变了。而且，如果我们能把事情做得更极致，为什么不去做呢？

另外，也不要觉得这些是运维或者[后端工程师](https://www.zhihu.com/search?q=后端工程师&search_source=Entity&hybrid_search_source=Entity&hybrid_search_extra={"sourceType"%3A"answer"%2C"sourceId"%3A32602154})要解决的问题。如果由其他角色来解决，**大家总是把自己不关心的问题丢给别人**，那么前端工程师的开发过程将受到极大的限制，这种情况甚至在某些大公司都不少见！

https://www.zhihu.com/question/20790576/answer/32602154

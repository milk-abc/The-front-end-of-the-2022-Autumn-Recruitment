![img](https://pica.zhimg.com/80/v2-a12089d5fea727332a8aba4ce009891a_720w.webp?source=d16d100b)

1.缓存的作用：可以降低资源的重复加载提高网页的整体加载速度

2.浏览器缓存策略：强缓存和协商缓存

基本原理：

1）浏览器在加载资源时，根据请求头的expires和cache-control判断是否命中强缓存，是则直接从缓存读取资源，不会发请求到服务器，返回状态码为200(from cache)。

2）如果没有命中强缓存，浏览器一定会发送一个请求到服务器，通过last-modified和etag验证资源是否命中协商缓存，如果命中，服务器会将这个请求返回，但是不会返回这个资源的数据，依然是从缓存中读取资源，返回状态码为304。

3）如果前面两者都没有命中，直接从服务器加载资源

强调一点：所有的缓存标识都是服务器生成的，expires,cache-control,last-modified,etag，想想token是怎么实现的，缓存标识是一样的，都是第一次请求发送到服务器，服务器生成缓存标识发给客户端，客户端下次请求带上标识和服务器进行对比，再执行以下操作。

强缓存

1)expires

当我们请求一个资源，服务器返回时，可以在Response Header中添加expires字段表示资源的过期时间。

![img](https://picx.zhimg.com/80/v2-7d73c719873a6d254b113cdaee9a2378_720w.webp?source=d16d100b)

当客户端再次请求该资源的时候，会把客户端时间与expire时间(绝对时间)进行对比，如果小于该时间直接使用该缓存资源。但客户端和服务端时间可能快慢不一致，另一方面，客户端的时间可以自行修改，可能会出现缓存混乱。

2)cache-control

cache-control是http1.1引入来解决此问题的，因此当cache-control和expires都存在时，cache-control优先级更高。一般常用该字段的`max-age`值来进行判断，它是一个相对时间，比如 .`Cache-Control:max-age=3600`代表资源的有效期是 3600 秒。并且返回头中的`Date`表示消息发送的时间，表示当前资源在`Date ~ Date +3600s`这段时间里都是有效的。

- `no-cache` 可以存储到本地，但是在与服务器进行新鲜度再验证前，缓存不能将其提供给客户端使用。
- `no-store`直接禁止浏览器缓存数据，每次请求资源都会向服务器要完整的资源， 类似于 `network` 中的 `disabled cache`。
- `public` 可以被所有用户缓存，包括终端用户和 cdn 等中间件代理服务器。
- `private` 只能被终端用户的浏览器缓存。

协商缓存

1)last-modified

last-modified记录资源最后修改的时间。启用后，请求资源之后的响应头会增加一个last-modified字段，如上。

当再次请求该资源时，请求头中会带有if-modified-since字段，值是之前返回的last-modified的值。服务端会对比该字段和last-modified，若一致则证明没有被修改，告知浏览器可直接使用客户端的缓存并返回304；若不一致则直接返回服务器的修改后的资源，返回200 ，客户端如第一次接受该资源一样，记下它的cache-control中的max-age、etag、last-modified等。

但是last-modified有以下两个缺点：

1、只要编辑了，不管内容是否真的有改变，都会以这最后修改的时间作为判断依据，当成新资源返回，从而导致了没必要的请求响应

2、时间的精确度只能到秒，如果在一秒内的修改是检测不到更新的，依然会告知浏览器使用旧的缓存。

3、某些服务器不能精确的得到文件的最后修改时间。

2)etag

为了解决上述问题，引入了etag，因此etag的优先级高于last-modified，etag就像一个指纹，资源变化都会导致etag变化，跟最后修改时间没有关系，Etag可以保证每一个资源是唯一的。

当再次请求该资源时，请求头中会带有If-None-Match字段，值是之前返回的etag的值，询问服务器该资源的etag是否有更新。



![img](https://pica.zhimg.com/80/v2-e231d2d654aa2b972eee7109539becbc_720w.webp?source=d16d100b)

整体流程

![img](https://picx.zhimg.com/80/v2-06c8da98ecbf4bd352046daafcbd9660_720w.webp?source=d16d100b)

Cookie、sessionStorage、localStorage、indexdb 的区别

cookie数据在http请求中携带，4KB

sessionStorage、localStorage仅在本地保存，5M，移动端2.5M，indexdb 50M

cookie一般有服务器生成，可设置失效时间。如果在浏览器端生成的cookie，默认关闭浏览器后失效

##### sessionStorage仅在当前浏览器窗口关闭前有效

localStorage始终有效，窗口或浏览器关闭也一直保存，因此用作持久数据

indexDB持久数据

------------------------------------------------------------------------------------------------------

sessionStorage不在不同的浏览器窗口中共享，即使是同一个页面

cookie在所有同源窗口中都是共享的

localStorage 在所有同源窗口中都是共享的

indexDB异步，支持事务，较为复杂


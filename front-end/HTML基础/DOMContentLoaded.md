为什么我们建议把 script 标签放在</body>之前而不是 head 里面呢？为什么有时候我们访问 DOM 却访问不到呢？
有的时候需要使用 window.onload 将脚本包含进去。
HTML 页面的生命周期包含三个重要事件：
DOMContentLoaded：浏览器已完全加载 HTML，并构建了 DOM 树，但像<img>和样式表之类的外部资源可能尚未加载完成。此时 DOM 已经就绪，因此处理程序可以查找 DOM 节点，并初始化接口。
load：浏览器不仅加载完成了 HTML，还加载完成了所有外部资源：图片，样式等。
beforeunload/unload：当用户正在离开页面时
html 页面的渲染过程
先构建 dom 树，再根据 dom 树构建渲染树，然后浏览器将渲染树绘制到页面上。
构建 dom 树的过程即根据 html 代码自上而下进行构建，当遇到 script 文件加载/执行会阻塞后面 dom 树的构建
而遇到 css 文件则会阻塞渲染树的构建，但 dom 树依然继续构建，除非遇到 script 标签并且 css 文件还未加载完成。
当解析器发现非阻塞资源，例如一张图片，浏览器会请求这些资源并且继续解析。当遇到一个 CSS 文件时，解析也可以继续进行，但是对于<script>标签（特别是没有 async 或者 defer 属性）会阻塞渲染并停止 HTML 的解析。尽管浏览器的预加载扫描器加速了这个过程，但过多的脚本仍然是一个重要的瓶颈。 1.浏览器构建 DOM 树时，这个过程占用了主线程。当这种情况发生时，预加载扫描仪将解析可用的内容并请求高优先级资源，如 CSS、JavaScript 和 web 字体。多亏了预加载扫描器，我们不必等到解析器找到对外部资源的引用来请求它。它将在后台检索资源，以便在主 HTML 解析器到达请求的资源时，它们可能已经在运行，或者已经被下载。预加载扫描仪提供的优化减少了阻塞。

<link rel="stylesheet" src="styles.css"/>
<script src="myscript.js" async></script>
<img src="myimage.jpg" alt="image description"/>
<script src="anotherscript.js" async></script>
在这个例子中，当主线程在解析HTML和CSS时，预加载扫描器将找到脚本和图像，并开始下载它们。为了确保脚本不会阻塞进程，当JavaScript解析和执行顺序不重要时，可以添加async属性或defer属性。
等待获取CSS不会阻塞HTML的解析或者下载，但是它的确阻塞JavaScript，因为JavaScript经常用于查询元素的CSS属性。
2.浏览器处理CSS并构建CSSOM树。构建CSSOM非常非常快。
3.将DOM和CSSOM组合成一个Render树，计算样式树或渲染树从DOM树的根开始构建，遍历每个可见节点。
4.在渲染树上运行布局以计算每个节点的几何体。布局是确定呈现树中所有节点的宽度、高度和位置，以及确定页面上每个对象的大小和位置的过程。回流是对页面的任何部分或整个文档的任何后续大小和位置的确定。
5.将各个节点绘制到屏幕上。
6.当文档的各个部分以不同的层绘制，相互重叠时，必须进行合成，以确保它们以正确的顺序绘制到屏幕上。
浏览器内核是多线程，有GUI渲染线程，JS引擎线程，定时器触发器线程，事件触发线程，异步http请求线程
GUI渲染线程和JS引擎线程是互斥的，在JS引擎运行脚本期间，GUI渲染线程是挂起状态的
将任务交给事件触发线程和异步http请求线程，当对应的任务符合触发条件时，会把事件添加到待处理队列的队尾，等待JS引擎的处理。
如果Javascript是多线程的话，在多线程的交互下，处于UI中的DOM节点就可能成为一个临界资源，假设存在两个线程同时操作一个DOM，一个负责修改一个负责删除，那么这个时候就需要浏览器来裁决如何生效哪个线程的执行结果。
当然我们可以通过锁来解决上面的问题。但为了避免因为引入了锁而带来更大的复杂性，Javascript在最初就选择了单线程执行。
这也解释了为什么GUI线程和JS引擎是互斥的。
